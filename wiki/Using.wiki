#summary How to use muparserx in your projects

= Using the library =
== Getting the latest source code ==
A stable version of muParserX is available for download at the muParser site on google code. The latest source code can be checked out from the muParser SVN repository using the following command:

*svn checkout http://muparserx.googlecode.com/svn/trunk/ muparserx-read-only*

Although i never deliberately check in broken versions this is a development snapshots which may not always compile on all systems and may not pass its UNIT test without errors. Most time this does'nt mean it contains more bugs than the official release it just means i added new tests for previousely unknown bugs to the unit test.

== Adding the library to your projects ==
This library depends on the Standard template library (STL). The problem with the STL is that every C++ compiler has its own implementation of the STL and different STL implementations are not compatible in terms of their memory layout. Since STL template classes are used in the API of muParserX I do not see a maintainable way to provide a prebuild library. Your only choice of using the library is adding its source code directly to your project. So In order to use the library you should add all files located in the "muparserx/parser" subdiretory into your own project. The library currently comes with project files for VisualStudio 2008 and a Makefile for the GNU C++ compiler but It should compile on every standard compliant C++ compiler. 

== Basic design concept ==
Before starting I should give you an overview over the classes related to muParserX. Parsing works by splitting the mathematical expression into so called tokens. A token can be either a value, a variable, a function call, an operator or a special character such as brackets or commas. The tokens will be stored internally for processing during the evaluation process. When using the parser you will deal with tokens directly only when setting variables, constants functions or operators.

<img src="http://beltoforion.de/muparserx/mup_tokens.png"/>

The parser defines an abstract base class named mup::IToken from which all of its tokens are derived. There are three major kinds of token: Value tokens, Callback tokens and generic tokens. Values represent either constants or variables, callbacks represent functions and operators, generic tokens are used for brackets, commas and special characters.
It's important to know that muParserX handles its tokens via reference counted smartpointers using the mup::TokenPtr<...> template class. There is no need to release their pointers explicitely with the delete operator. The following typedefs represent smartpointer names: 

{{{
namespace mup
{
  // Type of a managed pointer storing parser tokens via their base type.
  typedef TokenPtr<IToken>   ptr_tok_type;

  // Type of a managed pointer storing value tokens via their base type. 
  typedef TokenPtr<IValue>   ptr_val_type;

  // Type of a managed pointer storing binary operator tokens. 
  typedef TokenPtr<IOprtBin> ptr_binop_type;
}
}}}

== Parser initialization ==
In order to use muParserX you have to include the file mpParser.h into your projects. The parser resides in the namespace mup.

{{{
#include "mpParser.h"

using namespace mup;
}}}

The parser functionality is organized in so called packages. A package consits of a set of predefined mathematical functions, operators and constants as well as value detection callbacks. Creating a parser instance is simple: The constructor takes an optional variable made up of several flags for activating certain parser packages. For convenience the parser already defines the enumeration values pckALL_COMPLEX and pckALL_NON_COMPLEX which can be used to configure the parser for either complex valued calculation or noncomplex calculations. If this parameter is omitted the parser will be run in its default mode which means it is using complex numbers and all available operators and functions will be installed (pckALL_COMPLEX).

{{{
ParserX  p(pckALL_NON_COMPLEX);
}}}

The following bits and bit combinations can be used for activating or deactivating certain parser packages at construction time:

    * pckCOMMON = 1; Installs common functionality such as binary operators and basic functions.
    * pckUNIT = 2; Installs postfix operators for unit conversions.
    * pckCOMPLEX = 4; Installs complex valued functions, operators and a constant for the imaginary unit i. The packages pckCOMPLEX and pckNON_COMPLEX are mutually exclusive.
    * pckNON_COMPLEX = 8; Installs noncomplex functions and operators. The packages pckCOMPLEX and pckNON_COMPLEX are mutually exclusive.
    * pckSTRING = 16; Installs functions for string manipulation and the binary string concetanation operator.
    * pckALL_COMPLEX = pckCOMMON | pckCOMPLEX | pckSTRING | pckUNIT
    * pckALL_NON_COMPLEX = pckCOMMON | pckNON_COMPLEX | pckSTRING | pckUNIT